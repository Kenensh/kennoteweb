<!DOCTYPE html>
<html lang="zh-TW" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 狀態管理 | React State Management</title>
    <!-- Tailwind CSS 和 DaisyUI CDN -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.3/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 自訂 Tailwind 配置 -->
    <script>
        tailwind.config = {
            daisyui: {
                themes: ["light", "dark"],
            },
        }
    </script>
</head>
<body class="bg-base-100 text-base-content min-h-screen flex flex-col">
    <!-- 導航欄 -->
    <nav class="navbar bg-base-100 shadow-sm sticky top-0 z-10">
        <div class="flex justify-center w-full">
            <div class="flex gap-2">
                <a href="../../frontend/index.html" class="btn btn-sm">
                    <span class="lang-zh">前端技術</span>
                    <span class="lang-en hidden">Frontend</span>
                </a>
                <a href="../../backend/index.html" class="btn btn-sm btn-ghost">
                    <span class="lang-zh">後端技術</span>
                    <span class="lang-en hidden">Backend</span>
                </a>
                <a href="../../ui/index.html" class="btn btn-sm btn-ghost">UI</a>
                <a href="../../figma/index.html" class="btn btn-sm btn-ghost">Figma</a>
                <a href="../../tools/index.html" class="btn btn-sm btn-ghost">
                    <span class="lang-zh">工具</span>
                    <span class="lang-en hidden">Tools</span>
                </a>
                <a href="../../ai/index.html" class="btn btn-sm btn-ghost">AI</a>
            </div>
        </div>
        <div class="navbar-end">
            <!-- 語言切換 -->
            <button id="langToggle" class="btn btn-ghost">
                <span id="langDisplay">中/EN</span>
            </button>
            <!-- 主題切換 -->
            <button id="themeToggle" class="btn btn-ghost btn-circle">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 theme-light" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                </svg>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 theme-dark hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                </svg>
            </button>
        </div>
    </nav>
    </nav>

    <!-- 麵包屑導航 -->
    <div class="text-sm breadcrumbs bg-base-200 p-4">
        <ul>
            <li><a href="../../../index.html" class="lang-zh">首頁</a><a href="../../../index.html" class="lang-en hidden">Home</a></li>
            <li><a href="../../frontend/index.html" class="lang-zh">前端技術</a><a href="../../frontend/index.html" class="lang-en hidden">Frontend</a></li>
            <li><a href="index.html">React</a></li>
            <li class="lang-zh">狀態管理</li>
            <li class="lang-en hidden">State Management</li>
        </ul>
    </div>

    <!-- 主要內容 -->
    <main class="container mx-auto px-4 py-8 flex-grow">
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- 側邊欄 -->
            <div class="lg:col-span-1">
                <div class="sticky top-20">
                    <div class="card bg-base-200">
                        <div class="card-body">
                            <h2 class="text-xl font-bold mb-4">
                                <span class="lang-zh">React 筆記目錄</span>
                                <span class="lang-en hidden">React Contents</span>
                            </h2>
                            <ul class="menu bg-base-200 rounded-box">
                                <li><a href="index.html">React 概覽</a></li>
                                <li><a href="hooks-best-practices.html" class="lang-zh">Hooks 最佳實踐</a><a href="hooks-best-practices.html" class="lang-en hidden">Hooks Best Practices</a></li>
                                <li><a href="state-management.html" class="active lang-zh">狀態管理</a><a href="state-management.html" class="active lang-en hidden">State Management</a></li>
                                <li><a href="context-api.html" class="lang-zh">Context API 使用指南</a><a href="context-api.html" class="lang-en hidden">Context API Guide</a></li>
                                <li><a href="performance.html" class="lang-zh">效能優化技巧</a><a href="performance.html" class="lang-en hidden">Performance Optimization</a></li>
                                <li><a href="testing.html" class="lang-zh">測試 React 應用</a><a href="testing.html" class="lang-en hidden">Testing React Apps</a></li>
                                <li><a href="server-components.html" class="lang-zh">React 服務器組件</a><a href="server-components.html" class="lang-en hidden">React Server Components</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 主要內容區 -->
            <div class="lg:col-span-3">
                <article class="prose max-w-none">
                    <header class="mb-8 not-prose">
                        <h1 class="text-4xl font-bold mb-2">
                            <span class="lang-zh">React 狀態管理詳解</span>
                            <span class="lang-en hidden">Complete Guide to React State Management</span>
                        </h1>
                        <div class="flex items-center gap-4 text-sm opacity-70 mb-4">
                            <time datetime="2025-05-20">2025-05-20</time>
                            <span>|</span>
                            <span class="badge badge-outline">React</span>
                            <span class="badge badge-outline">State</span>
                            <span class="badge badge-outline">Context</span>
                            <span class="badge badge-outline">Redux</span>
                        </div>
                    </header>

                    <!-- 文章目錄 -->
                    <div class="card bg-base-200 mb-8">
                        <div class="card-body">
                            <h2 class="card-title text-xl mb-2">
                                <span class="lang-zh">目錄</span>
                                <span class="lang-en hidden">Contents</span>
                            </h2>
                            <ul class="lang-zh">
                                <li><a href="#introduction">狀態管理概述</a></li>
                                <li><a href="#small-apps">小型應用的狀態管理</a>
                                    <ul class="ml-4">
                                        <li><a href="#useState">useState</a></li>
                                        <li><a href="#useReducer">useReducer</a></li>
                                    </ul>
                                </li>
                                <li><a href="#medium-apps">中型應用的狀態管理</a>
                                    <ul class="ml-4">
                                        <li><a href="#context-api">Context API</a></li>
                                        <li><a href="#custom-hooks">自定義 Hooks</a></li>
                                        <li><a href="#composition">組件組合</a></li>
                                    </ul>
                                </li>
                                <li><a href="#large-apps">大型應用的狀態管理</a>
                                    <ul class="ml-4">
                                        <li><a href="#redux">Redux</a></li>
                                        <li><a href="#redux-toolkit">Redux Toolkit</a></li>
                                        <li><a href="#zustand">Zustand</a></li>
                                        <li><a href="#recoil">Recoil</a></li>
                                        <li><a href="#jotai">Jotai</a></li>
                                    </ul>
                                </li>
                                <li><a href="#comparison">各方案比較</a></li>
                                <li><a href="#selection-guide">選擇指南</a></li>
                                <li><a href="#best-practices">最佳實踐</a></li>
                                <li><a href="#conclusion">總結</a></li>
                            </ul>
                            <ul class="lang-en hidden">
                                <li><a href="#introduction">State Management Overview</a></li>
                                <li><a href="#small-apps">State Management for Small Apps</a>
                                    <ul class="ml-4">
                                        <li><a href="#useState">useState</a></li>
                                        <li><a href="#useReducer">useReducer</a></li>
                                    </ul>
                                </li>
                                <li><a href="#medium-apps">State Management for Medium Apps</a>
                                    <ul class="ml-4">
                                        <li><a href="#context-api">Context API</a></li>
                                        <li><a href="#custom-hooks">Custom Hooks</a></li>
                                        <li><a href="#composition">Component Composition</a></li>
                                    </ul>
                                </li>
                                <li><a href="#large-apps">State Management for Large Apps</a>
                                    <ul class="ml-4">
                                        <li><a href="#redux">Redux</a></li>
                                        <li><a href="#redux-toolkit">Redux Toolkit</a></li>
                                        <li><a href="#zustand">Zustand</a></li>
                                        <li><a href="#recoil">Recoil</a></li>
                                        <li><a href="#jotai">Jotai</a></li>
                                    </ul>
                                </li>
                                <li><a href="#comparison">Comparison of Solutions</a></li>
                                <li><a href="#selection-guide">Selection Guide</a></li>
                                <li><a href="#best-practices">Best Practices</a></li>
                                <li><a href="#conclusion">Conclusion</a></li>
                            </ul>
                        </div>
                    </div>

                    <!-- 狀態管理概述 -->
                    <section id="introduction">
                        <h2 class="lang-zh">狀態管理概述</h2>
                        <h2 class="lang-en hidden">State Management Overview</h2>
                        
                        <p class="lang-zh">
                            在 React 應用中，狀態管理是指如何組織和控制應用的數據流動。無論是簡單的表單控件狀態、頁面間的共享數據，還是全應用的主題設置，良好的狀態管理策略對於構建可維護和高效的 React 應用至關重要。
                        </p>
                        <p class="lang-en hidden">
                            In React applications, state management refers to how you organize and control the flow of data. Whether it's simple form control states, data shared between pages, or application-wide settings like themes, a good state management strategy is crucial for building maintainable and efficient React applications.
                        </p>
                        
                        <div class="bg-base-200 p-4 rounded-lg my-4">
                            <h3 class="font-bold lang-zh">狀態的類型</h3>
                            <h3 class="font-bold lang-en hidden">Types of State</h3>
                            <ul>
                                <li class="lang-zh"><strong>局部狀態</strong>：僅在單個組件中使用的數據</li>
                                <li class="lang-en hidden"><strong>Local State</strong>: Data used only within a single component</li>
                                
                                <li class="lang-zh"><strong>共享狀態</strong>：在多個組件之間共享的數據</li>
                                <li class="lang-en hidden"><strong>Shared State</strong>: Data shared between multiple components</li>
                                
                                <li class="lang-zh"><strong>全局狀態</strong>：整個應用中都可訪問的數據</li>
                                <li class="lang-en hidden"><strong>Global State</strong>: Data accessible throughout the entire application</li>
                                
                                <li class="lang-zh"><strong>服務器狀態</strong>：來自服務器的數據，通常需要同步和緩存</li>
                                <li class="lang-en hidden"><strong>Server State</strong>: Data from the server that typically needs synchronization and caching</li>
                                
                                <li class="lang-zh"><strong>URL 狀態</strong>：存儲在 URL 中的數據</li>
                                <li class="lang-en hidden"><strong>URL State</strong>: Data stored in the URL</li>
                            </ul>
                        </div>
                        
                        <p class="lang-zh">
                            根據應用的複雜度和需求，我們應選擇不同的狀態管理方案。接下來，我們將探討從小型到大型應用的各種狀態管理策略。
                        </p>
                        <p class="lang-en hidden">
                            Based on the complexity and requirements of your application, different state management solutions should be chosen. Next, we'll explore various state management strategies for applications ranging from small to large.
                        </p>
                    </section>

                    <!-- 小型應用的狀態管理 -->
                    <section id="small-apps">
                        <h2 class="lang-zh">小型應用的狀態管理</h2>
                        <h2 class="lang-en hidden">State Management for Small Apps</h2>
                        
                        <p class="lang-zh">
                            對於小型應用，React 內置的狀態管理 Hook 通常已經足夠使用。這些 Hook 簡單、輕量，不需要引入額外的依賴。
                        </p>
                        <p class="lang-en hidden">
                            For small applications, React's built-in state management hooks are usually sufficient. These hooks are simple, lightweight, and don't require additional dependencies.
                        </p>
                        
                        <section id="useState">
                            <h3 class="lang-zh">useState</h3>
                            <h3 class="lang-en hidden">useState</h3>
                            
                            <p class="lang-zh">
                                <code>useState</code> 是最基本的狀態管理 Hook，適合管理簡單的狀態值。它返回當前狀態值和一個更新它的函數。
                            </p>
                            <p class="lang-en hidden">
                                <code>useState</code> is the most basic state management hook, suitable for managing simple state values. It returns the current state value and a function to update it.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>import React, { useState } from 'react';

function Counter() {
  // 聲明一個名為 "count" 的狀態變量，初始值為 0
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">useState 最佳實踐</h4>
                                <h4 class="font-bold lang-en hidden">useState Best Practices</h4>
                                <ul>
                                    <li class="lang-zh"><strong>使用函數更新</strong>：當新狀態依賴於先前的狀態時，使用函數形式</li>
                                    <li class="lang-en hidden"><strong>Functional Updates</strong>: Use the functional form when the new state depends on the previous state</li>
                                    
                                    <li class="lang-zh"><strong>合理拆分狀態</strong>：相關的狀態應該組合在一起，不相關的狀態應該分開</li>
                                    <li class="lang-en hidden"><strong>Split State Wisely</strong>: Group related state together, separate unrelated state</li>
                                    
                                    <li class="lang-zh"><strong>避免過度使用</strong>：當組件中有太多的 useState 時，考慮使用 useReducer</li>
                                    <li class="lang-en hidden"><strong>Avoid Overuse</strong>: Consider useReducer when a component has too many useState calls</li>
                                </ul>
                            </div>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// 使用函數更新狀態（推薦）
const increment = () => {
  setCount(prevCount => prevCount + 1);
};

// 使用對象組合相關狀態
const [user, setUser] = useState({
  name: '',
  email: '',
  age: 0
});

// 更新對象狀態的一部分
setUser(prevUser => ({
  ...prevUser,
  name: 'New Name'
}));</code></pre>
                            </div>
                        </section>
                        
                        <section id="useReducer">
                            <h3 class="lang-zh">useReducer</h3>
                            <h3 class="lang-en hidden">useReducer</h3>
                            
                            <p class="lang-zh">
                                當狀態邏輯變得複雜或涉及多個子值時，<code>useReducer</code> 可能比 <code>useState</code> 更適合。它接受一個 reducer 函數和初始狀態，返回當前狀態和 dispatch 函數。
                            </p>
                            <p class="lang-en hidden">
                                When state logic becomes complex or involves multiple sub-values, <code>useReducer</code> might be more appropriate than <code>useState</code>. It accepts a reducer function and an initial state, returning the current state and a dispatch function.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>import React, { useReducer } from 'react';

// Reducer 函數
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error();
  }
}

function Counter() {
  // 使用 useReducer
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <div>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">useReducer 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of useReducer</h4>
                                <ul>
                                    <li class="lang-zh"><strong>集中狀態邏輯</strong>：所有狀態更新邏輯都集中在一個 reducer 函數中</li>
                                    <li class="lang-en hidden"><strong>Centralized State Logic</strong>: All state update logic is centralized in a reducer function</li>
                                    
                                    <li class="lang-zh"><strong>可預測性</strong>：通過定義明確的 action 類型，使狀態變化更加可預測</li>
                                    <li class="lang-en hidden"><strong>Predictability</strong>: State changes become more predictable with well-defined action types</li>
                                    
                                    <li class="lang-zh"><strong>可測試性</strong>：Reducer 是純函數，易於測試</li>
                                    <li class="lang-en hidden"><strong>Testability</strong>: Reducers are pure functions, making them easy to test</li>
                                    
                                    <li class="lang-zh"><strong>適合複雜狀態</strong>：當狀態邏輯涉及多個子值或依賴於先前的狀態時特別有用</li>
                                    <li class="lang-en hidden"><strong>Suitable for Complex State</strong>: Particularly useful when state logic involves multiple sub-values or depends on previous state</li>
                                </ul>
                            </div>
                        </section>
                    </section>
                    
                    <!-- 中型應用的狀態管理 -->
                    <section id="medium-apps">
                        <h2 class="lang-zh">中型應用的狀態管理</h2>
                        <h2 class="lang-en hidden">State Management for Medium Apps</h2>
                        
                        <p class="lang-zh">
                            隨著應用規模增加，僅靠組件級的狀態管理可能導致 props drilling（屬性層層傳遞）問題。對於中型應用，以下解決方案可以幫助更好地組織狀態。
                        </p>
                        <p class="lang-en hidden">
                            As application size increases, component-level state management alone may lead to props drilling issues. For medium-sized applications, the following solutions can help better organize state.
                        </p>
                        
                        <section id="context-api">
                            <h3 class="lang-zh">Context API</h3>
                            <h3 class="lang-en hidden">Context API</h3>
                            
                            <p class="lang-zh">
                                Context API 允許跨組件共享數據，無需通過 props 層層傳遞。它包含三個主要部分：Context 對象、Provider 和 Consumer。
                            </p>
                            <p class="lang-en hidden">
                                The Context API allows data sharing across components without passing props through each level. It consists of three main parts: the Context object, Provider, and Consumer.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// ThemeContext.js
import React, { createContext, useState, useContext } from 'react';

// 創建 Context
const ThemeContext = createContext();

// 創建 Provider 組件
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  // 提供值給所有子組件
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 創建自定義 Hook 以便使用 Context
export function useTheme() {
  return useContext(ThemeContext);
}

// App.js
import React from 'react';
import { ThemeProvider } from './ThemeContext';
import ThemedButton from './ThemedButton';

function App() {
  return (
    <ThemeProvider>
      <div>
        <h1>Theme Example</h1>
        <ThemedButton />
      </div>
    </ThemeProvider>
  );
}

// ThemedButton.js
import React from 'react';
import { useTheme } from './ThemeContext';

function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button
      style={{
        backgroundColor: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff',
      }}
      onClick={toggleTheme}
    >
      Toggle Theme
    </button>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Context API 使用技巧</h4>
                                <h4 class="font-bold lang-en hidden">Context API Tips</h4>
                                <ul>
                                    <li class="lang-zh"><strong>拆分 Context</strong>：將不同域的狀態放在不同的 Context 中，避免不必要的重渲染</li>
                                    <li class="lang-en hidden"><strong>Split Contexts</strong>: Place state from different domains in separate contexts to avoid unnecessary re-renders</li>
                                    
                                    <li class="lang-zh"><strong>結合 useReducer</strong>：對於複雜的狀態邏輯，將 Context 與 useReducer 結合使用</li>
                                    <li class="lang-en hidden"><strong>Combine with useReducer</strong>: For complex state logic, combine Context with useReducer</li>
                                    
                                    <li class="lang-zh"><strong>考慮性能</strong>：Context 值變化會導致所有消費組件重新渲染，注意優化</li>
                                    <li class="lang-en hidden"><strong>Consider Performance</strong>: Changes to Context values cause all consuming components to re-render, so optimize carefully</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="custom-hooks">
                            <h3 class="lang-zh">自定義 Hooks</h3>
                            <h3 class="lang-en hidden">Custom Hooks</h3>
                            
                            <p class="lang-zh">
                                自定義 Hooks 可以封裝和重用狀態邏輯，使代碼更易於維護和測試。它們可以與 Context 結合，提供一種優雅的狀態共享解決方案。
                            </p>
                            <p class="lang-en hidden">
                                Custom Hooks can encapsulate and reuse state logic, making code more maintainable and testable. They can be combined with Context to provide an elegant state sharing solution.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// useLocalStorage.js - 一個使用 localStorage 的自定義 Hook
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // 獲取初始值（從 localStorage 或使用提供的初始值）
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  // 當 key 或 value 改變時更新 localStorage
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  }, [key, value]);
  
  return [value, setValue];
}

// 在組件中使用
function SettingsForm() {
  const [settings, setSettings] = useLocalStorage('app-settings', {
    theme: 'light',
    notifications: true
  });
  
  const toggleTheme = () => {
    setSettings({
      ...settings,
      theme: settings.theme === 'light' ? 'dark' : 'light'
    });
  };
  
  return (
    <div>
      <p>Current theme: {settings.theme}</p>
      <button onClick={toggleTheme}>Toggle Theme</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">自定義 Hooks 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of Custom Hooks</h4>
                                <ul>
                                    <li class="lang-zh"><strong>邏輯重用</strong>：在多個組件之間共享狀態邏輯，減少代碼重複</li>
                                    <li class="lang-en hidden"><strong>Logic Reuse</strong>: Share state logic between multiple components, reducing code duplication</li>
                                    
                                    <li class="lang-zh"><strong>關注點分離</strong>：將複雜的狀態邏輯從視圖層分離出來</li>
                                    <li class="lang-en hidden"><strong>Separation of Concerns</strong>: Separate complex state logic from the view layer</li>
                                    
                                    <li class="lang-zh"><strong>組合性</strong>：自定義 Hooks 可以組合使用，創建更強大的抽象</li>
                                    <li class="lang-en hidden"><strong>Composability</strong>: Custom Hooks can be used together to create more powerful abstractions</li>
                                    
                                    <li class="lang-zh"><strong>測試性</strong>：隔離的邏輯更容易進行單元測試</li>
                                    <li class="lang-en hidden"><strong>Testability</strong>: Isolated logic is easier to unit test</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="composition">
                            <h3 class="lang-zh">組件組合</h3>
                            <h3 class="lang-en hidden">Component Composition</h3>
                            
                            <p class="lang-zh">
                                有時候，狀態管理問題可以通過良好的組件組合來解決，而不需要引入複雜的狀態管理方案。React 的組件組合模式可以幫助避免 props drilling。
                            </p>
                            <p class="lang-en hidden">
                                Sometimes, state management problems can be solved through good component composition rather than introducing complex state management solutions. React's component composition patterns can help avoid props drilling.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// 使用 children prop 進行組合
function Page({ children }) {
  const [user, setUser] = useState(null);
  
  // 假設這是從 API 獲取用戶的邏輯
  useEffect(() => {
    fetchUser().then(setUser);
  }, []);
  
  // 將 user 作為 prop 傳遞給子組件
  return (
    <div className="page">
      {user ? React.Children.map(children, child =>
        React.cloneElement(child, { user })
      ) : <Loading />}
    </div>
  );
}

// 使用 compound components 模式
function Tabs({ children, defaultTab }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  );
}

Tabs.TabList = function TabList({ children }) {
  return (
    <div className="tab-list">
      {children}
    </div>
  );
};

Tabs.Tab = function Tab({ value, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  
  return (
    <button 
      className={`tab ${value === activeTab ? 'active' : ''}`}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  );
};

Tabs.Panel = function Panel({ value, children }) {
  const { activeTab } = useContext(TabsContext);
  
  return value === activeTab ? (
    <div className="tab-panel">{children}</div>
  ) : null;
};</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">常用的組件組合模式</h4>
                                <h4 class="font-bold lang-en hidden">Common Component Composition Patterns</h4>
                                <ul>
                                    <li class="lang-zh"><strong>容器/展示模式</strong>：將狀態邏輯和視圖分離</li>
                                    <li class="lang-en hidden"><strong>Container/Presentational Pattern</strong>: Separate state logic from views</li>
                                    
                                    <li class="lang-zh"><strong>複合組件模式</strong>：創建具有內部狀態共享的相關組件集合</li>
                                    <li class="lang-en hidden"><strong>Compound Components Pattern</strong>: Create related sets of components with shared internal state</li>
                                    
                                    <li class="lang-zh"><strong>渲染屬性模式</strong>：使用函數作為 props 來共享狀態</li>
                                    <li class="lang-en hidden"><strong>Render Props Pattern</strong>: Use functions as props to share state</li>
                                    
                                    <li class="lang-zh"><strong>控制反轉</strong>：通過 children 或其他 props 將控制邏輯移交給父組件</li>
                                    <li class="lang-en hidden"><strong>Inversion of Control</strong>: Hand control to parent components via children or other props</li>
                                </ul>
                            </div>
                        </section>
                    </section>
                    
                    <!-- 大型應用的狀態管理 -->
                    <section id="large-apps">
                        <h2 class="lang-zh">大型應用的狀態管理</h2>
                        <h2 class="lang-en hidden">State Management for Large Apps</h2>
                        
                        <p class="lang-zh">
                            對於大型和複雜的應用，專門的狀態管理庫可以提供更強大的功能和更好的可擴展性。這些庫通常提供更強的開發工具、中間件支持和性能優化。
                        </p>
                        <p class="lang-en hidden">
                            For large and complex applications, dedicated state management libraries can provide more powerful features and better scalability. These libraries typically offer stronger development tools, middleware support, and performance optimizations.
                        </p>
                        
                        <section id="redux">
                            <h3 class="lang-zh">Redux</h3>
                            <h3 class="lang-en hidden">Redux</h3>
                            
                            <p class="lang-zh">
                                Redux 是最流行的 React 狀態管理庫之一，基於單一不可變狀態樹和純函數 reducers 的原則。它提供可預測的狀態管理和強大的開發工具。
                            </p>
                            <p class="lang-en hidden">
                                Redux is one of the most popular state management libraries for React, based on the principles of a single immutable state tree and pure function reducers. It offers predictable state management and powerful development tools.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// store.js - Redux 存儲配置
import { createStore } from 'redux';

// 初始狀態
const initialState = {
  counter: 0,
  todos: []
};

// Reducer 函數
function rootReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return {
        ...state,
        counter: state.counter + 1
      };
    case 'DECREMENT':
      return {
        ...state,
        counter: state.counter - 1
      };
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    default:
      return state;
  }
}

// 創建存儲
const store = createStore(
  rootReducer,
  // 啟用 Redux DevTools
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);

export default store;

// 在 React 組件中使用 Redux
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  // 從 Redux store 讀取狀態
  const counter = useSelector(state => state.counter);
  // 獲取 dispatch 函數
  const dispatch = useDispatch();
  
  return (
    <div>
      <p>Count: {counter}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Redux 的核心概念</h4>
                                <h4 class="font-bold lang-en hidden">Core Concepts of Redux</h4>
                                <ul>
                                    <li class="lang-zh"><strong>單一真實來源</strong>：整個應用的狀態存儲在單一的存儲中</li>
                                    <li class="lang-en hidden"><strong>Single Source of Truth</strong>: The entire application state is stored in a single store</li>
                                    
                                    <li class="lang-zh"><strong>狀態是只讀的</strong>：唯一改變狀態的方法是發出 action</li>
                                    <li class="lang-en hidden"><strong>State is Read-Only</strong>: The only way to change state is to emit an action</li>
                                    
                                    <li class="lang-zh"><strong>使用純函數進行修改</strong>：reducers 是純函數，接收先前的狀態和 action，返回新的狀態</li>
                                    <li class="lang-en hidden"><strong>Changes are Made with Pure Functions</strong>: Reducers are pure functions that take the previous state and an action, and return the new state</li>
                                    
                                    <li class="lang-zh"><strong>單向數據流</strong>：狀態變化遵循嚴格的單向流動</li>
                                    <li class="lang-en hidden"><strong>Unidirectional Data Flow</strong>: State changes follow a strict one-way flow</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="redux-toolkit">
                            <h3 class="lang-zh">Redux Toolkit</h3>
                            <h3 class="lang-en hidden">Redux Toolkit</h3>
                            
                            <p class="lang-zh">
                                Redux Toolkit 是 Redux 團隊推薦的編寫 Redux 邏輯的方法，它簡化了 Redux 的使用，減少了樣板代碼，並內置了一些最佳實踐。
                            </p>
                            <p class="lang-en hidden">
                                Redux Toolkit is the recommended way to write Redux logic by the Redux team. It simplifies Redux usage, reduces boilerplate code, and incorporates best practices.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// features/counter/counterSlice.js
import { createSlice } from '@reduxjs/toolkit';

export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: state => {
      // Redux Toolkit 允許在 reducers 中直接 "修改" 狀態
      // 實際上它使用了 Immer 庫來產生不可變更新
      state.value += 1;
    },
    decrement: state => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

// 導出 action creators
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// 可以創建異步 thunk
export const incrementAsync = amount => dispatch => {
  setTimeout(() => {
    dispatch(incrementByAmount(amount));
  }, 1000);
};

// 選擇器可以用來獲取狀態片段
export const selectCount = state => state.counter.value;

// 導出 reducer
export default counterSlice.reducer;

// 在組件中使用
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import {
  increment,
  decrement,
  incrementAsync,
  selectCount,
} from './counterSlice';

export function Counter() {
  const count = useSelector(selectCount);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(incrementAsync(5))}>+ Async</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Redux Toolkit 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of Redux Toolkit</h4>
                                <ul>
                                    <li class="lang-zh"><strong>減少樣板代碼</strong>：使用 createSlice 自動生成 action 創建器和 action 類型</li>
                                    <li class="lang-en hidden"><strong>Less Boilerplate</strong>: Use createSlice to automatically generate action creators and action types</li>
                                    
                                    <li class="lang-zh"><strong>簡化不可變更新</strong>：使用 Immer 庫實現直觀的狀態更新語法</li>
                                    <li class="lang-en hidden"><strong>Simplified Immutable Updates</strong>: Use Immer for intuitive state update syntax</li>
                                    
                                    <li class="lang-zh"><strong>內置開發工具</strong>：默認配置 Redux DevTools</li>
                                    <li class="lang-en hidden"><strong>Built-in DevTools</strong>: Redux DevTools configured by default</li>
                                    
                                    <li class="lang-zh"><strong>內置中間件</strong>：預設包含 thunk 中間件，簡化異步邏輯</li>
                                    <li class="lang-en hidden"><strong>Built-in Middleware</strong>: Includes thunk middleware by default, simplifying async logic</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="zustand">
                            <h3 class="lang-zh">Zustand</h3>
                            <h3 class="lang-en hidden">Zustand</h3>
                            
                            <p class="lang-zh">
                                Zustand 是一個輕量級的狀態管理庫，使用簡單的 API 和鉤子方法。它比 Redux 更簡潔，同時保持了類似的概念。
                            </p>
                            <p class="lang-en hidden">
                                Zustand is a lightweight state management library with a simple API and hook-based approach. It's more concise than Redux while maintaining similar concepts.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// store.js
import create from 'zustand';

// 創建存儲
const useStore = create(set => ({
  bears: 0,
  increasePopulation: () => set(state => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 }),
  // 使用異步操作
  fetchBears: async () => {
    const response = await fetch('https://api.example.com/bears');
    const result = await response.json();
    set({ bears: result.count });
  }
}));

// 在組件中使用
function BearCounter() {
  const bears = useStore(state => state.bears);
  const increasePopulation = useStore(state => state.increasePopulation);
  
  return (
    <div>
      <h2>Bears: {bears}</h2>
      <button onClick={increasePopulation}>Add Bear</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Zustand 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of Zustand</h4>
                                <ul>
                                    <li class="lang-zh"><strong>簡單的 API</strong>：更少的樣板代碼和概念</li>
                                    <li class="lang-en hidden"><strong>Simple API</strong>: Less boilerplate and fewer concepts</li>
                                    
                                    <li class="lang-zh"><strong>基於 Hook</strong>：與 React 的 Hook 系統很好地集成</li>
                                    <li class="lang-en hidden"><strong>Hook-based</strong>: Integrates well with React's Hook system</li>
                                    
                                    <li class="lang-zh"><strong>不需要提供者</strong>：無需包裝應用於 Provider</li>
                                    <li class="lang-en hidden"><strong>No Provider Required</strong>: No need to wrap your app in a Provider</li>
                                    
                                    <li class="lang-zh"><strong>支持中間件</strong>：可以使用 Redux 開發工具、immer 等</li>
                                    <li class="lang-en hidden"><strong>Middleware Support</strong>: Can use Redux DevTools, immer, etc.</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="recoil">
                            <h3 class="lang-zh">Recoil</h3>
                            <h3 class="lang-en hidden">Recoil</h3>
                            
                            <p class="lang-zh">
                                Recoil 是由 Facebook 開發的狀態管理庫，專為 React 設計。它使用原子(atoms)和選擇器(selectors)的概念來管理狀態，提供精細的狀態更新和訂閱。
                            </p>
                            <p class="lang-en hidden">
                                Recoil is a state management library developed by Facebook, specifically designed for React. It uses the concepts of atoms and selectors to manage state, providing fine-grained state updates and subscriptions.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// atoms.js
import { atom, selector } from 'recoil';

// 定義原子（基本狀態單元）
export const todoListState = atom({
  key: 'todoListState',
  default: [],
});

// 定義選擇器（派生狀態）
export const todoListStatsState = selector({
  key: 'todoListStatsState',
  get: ({get}) => {
    const todoList = get(todoListState);
    const totalNum = todoList.length;
    const totalCompletedNum = todoList.filter(item => item.isComplete).length;
    const totalUncompletedNum = totalNum - totalCompletedNum;
    const percentCompleted = totalNum === 0 ? 0 : totalCompletedNum / totalNum;
    
    return {
      totalNum,
      totalCompletedNum,
      totalUncompletedNum,
      percentCompleted,
    };
  },
});

// 在組件中使用
import React from 'react';
import { useRecoilState, useRecoilValue } from 'recoil';
import { todoListState, todoListStatsState } from './atoms';

function TodoList() {
  // 讀取和更新狀態
  const [todoList, setTodoList] = useRecoilState(todoListState);
  // 只讀取派生狀態
  const stats = useRecoilValue(todoListStatsState);
  
  const addTodo = (text) => {
    setTodoList([
      ...todoList,
      {
        id: Date.now(),
        text,
        isComplete: false,
      },
    ]);
  };
  
  return (
    <div>
      <h2>Todo List ({stats.totalNum})</h2>
      <p>Completed: {stats.totalCompletedNum}</p>
      <button onClick={() => addTodo('New Task')}>Add Task</button>
      {/* 渲染任務列表 */}
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Recoil 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of Recoil</h4>
                                <ul>
                                    <li class="lang-zh"><strong>原子化狀態</strong>：將狀態分解為原子單元，實現精細控制</li>
                                    <li class="lang-en hidden"><strong>Atomic State</strong>: Break state down into atomic units for fine-grained control</li>
                                    
                                    <li class="lang-zh"><strong>派生狀態</strong>：使用選擇器輕鬆創建和訂閱派生狀態</li>
                                    <li class="lang-en hidden"><strong>Derived State</strong>: Easily create and subscribe to derived state with selectors</li>
                                    
                                    <li class="lang-zh"><strong>減少重新渲染</strong>：組件只在其使用的狀態變化時重新渲染</li>
                                    <li class="lang-en hidden"><strong>Reduced Re-renders</strong>: Components only re-render when the state they use changes</li>
                                    
                                    <li class="lang-zh"><strong>異步支持</strong>：內置對異步選擇器和並發模式的支持</li>
                                    <li class="lang-en hidden"><strong>Async Support</strong>: Built-in support for async selectors and concurrent mode</li>
                                </ul>
                            </div>
                        </section>
                        
                        <section id="jotai">
                            <h3 class="lang-zh">Jotai</h3>
                            <h3 class="lang-en hidden">Jotai</h3>
                            
                            <p class="lang-zh">
                                Jotai 是受 Recoil 啟發的更輕量的狀態管理庫，同樣基於原子概念但 API 更簡單。它專注於基於 Hooks 的原始性狀態管理。
                            </p>
                            <p class="lang-en hidden">
                                Jotai is a lighter state management library inspired by Recoil, also based on the atomic concept but with a simpler API. It focuses on primitive-based state management with Hooks.
                            </p>
                            
                            <div class="mockup-code my-6">
                                <pre><code>// atoms.js
import { atom } from 'jotai';

// 創建原子
export const countAtom = atom(0);

// 衍生原子（類似 selector）
export const doubleCountAtom = atom(
  get => get(countAtom) * 2
);

// 可寫的衍生原子
export const incrementCountAtom = atom(
  get => get(countAtom),
  (get, set, by = 1) => set(countAtom, get(countAtom) + by)
);

// 在組件中使用
import React from 'react';
import { useAtom } from 'jotai';
import { countAtom, doubleCountAtom, incrementCountAtom } from './atoms';

function Counter() {
  const [count] = useAtom(countAtom);
  const [doubleCount] = useAtom(doubleCountAtom);
  const [, increment] = useAtom(incrementCountAtom);
  
  return (
    <div>
      <h2>Count: {count}</h2>
      <p>Double: {doubleCount}</p>
      <button onClick={() => increment()}>Increment</button>
      <button onClick={() => increment(5)}>Increment by 5</button>
    </div>
  );
}</code></pre>
                            </div>
                            
                            <div class="bg-base-200 p-4 rounded-lg my-4">
                                <h4 class="font-bold lang-zh">Jotai 的優勢</h4>
                                <h4 class="font-bold lang-en hidden">Advantages of Jotai</h4>
                                <ul>
                                    <li class="lang-zh"><strong>輕量且簡單</strong>：API 比 Recoil 更簡單，庫體積更小</li>
                                    <li class="lang-en hidden"><strong>Lightweight and Simple</strong>: Simpler API than Recoil, smaller library size</li>
                                    
                                    <li class="lang-zh"><strong>原子化設計</strong>：從基本原子構建複雜狀態</li>
                                    <li class="lang-en hidden"><strong>Atomic Design</strong>: Build complex state from primitive atoms</li>
                                    
                                    <li class="lang-zh"><strong>良好的 TypeScript 支持</strong>：提供強大的類型推導</li>
                                    <li class="lang-en hidden"><strong>Good TypeScript Support</strong>: Provides robust type inferencing</li>
                                    
                                    <li class="lang-zh"><strong>與 React 集成</strong>：可以使用 React.Suspense 和並發模式</li>
                                    <li class="lang-en hidden"><strong>React Integration</strong>: Works with React.Suspense and concurrent mode</li>
                                </ul>
                            </div>
                        </section>
                    </section>
                    
                    <!-- 各方案比較 -->
                    <section id="comparison">
                        <h2 class="lang-zh">各方案比較</h2>
                        <h2 class="lang-en hidden">Comparison of Solutions</h2>
                        
                        <div class="overflow-x-auto">
                            <table class="table table-zebra">
                                <thead>
                                    <tr>
                                        <th class="lang-zh">方案</th>
                                        <th class="lang-en hidden">Solution</th>
                                        <th class="lang-zh">複雜度</th>
                                        <th class="lang-en hidden">Complexity</th>
                                        <th class="lang-zh">學習曲線</th>
                                        <th class="lang-en hidden">Learning Curve</th>
                                        <th class="lang-zh">適用場景</th>
                                        <th class="lang-en hidden">Use Cases</th>
                                        <th class="lang-zh">性能</th>
                                        <th class="lang-en hidden">Performance</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>useState</td>
                                        <td class="lang-zh">低</td>
                                        <td class="lang-en hidden">Low</td>
                                        <td class="lang-zh">容易</td>
                                        <td class="lang-en hidden">Easy</td>
                                        <td class="lang-zh">單組件狀態或簡單應用</td>
                                        <td class="lang-en hidden">Single component state or simple apps</td>
                                        <td class="lang-zh">良好</td>
                                        <td class="lang-en hidden">Good</td>
                                    </tr>
                                    <tr>
                                        <td>useReducer</td>
                                        <td class="lang-zh">中低</td>
                                        <td class="lang-en hidden">Medium-Low</td>
                                        <td class="lang-zh">較易</td>
                                        <td class="lang-en hidden">Fairly Easy</td>
                                        <td class="lang-zh">複雜組件狀態</td>
                                        <td class="lang-en hidden">Complex component state</td>
                                        <td class="lang-zh">良好</td>
                                        <td class="lang-en hidden">Good</td>
                                    </tr>
                                    <tr>
                                        <td>Context API</td>
                                        <td class="lang-zh">中</td>
                                        <td class="lang-en hidden">Medium</td>
                                        <td class="lang-zh">中等</td>
                                        <td class="lang-en hidden">Moderate</td>
                                        <td class="lang-zh">共享狀態的小型/中型應用</td>
                                        <td class="lang-en hidden">Small/medium apps with shared state</td>
                                        <td class="lang-zh">中等</td>
                                        <td class="lang-en hidden">Moderate</td>
                                    </tr>
                                    <tr>
                                        <td>Redux</td>
                                        <td class="lang-zh">高</td>
                                        <td class="lang-en hidden">High</td>
                                        <td class="lang-zh">陡峭</td>
                                        <td class="lang-en hidden">Steep</td>
                                        <td class="lang-zh">大型應用，複雜狀態邏輯</td>
                                        <td class="lang-en hidden">Large apps, complex state logic</td>
                                        <td class="lang-zh">良好</td>
                                        <td class="lang-en hidden">Good</td>
                                    </tr>
                                    <tr>
                                        <td>Redux Toolkit</td>
                                        <td class="lang-zh">中高</td>
                                        <td class="lang-en hidden">Medium-High</td>
                                        <td class="lang-zh">中等</td>
                                        <td class="lang-en hidden">Moderate</td>
                                        <td class="lang-zh">需要 Redux 但希望減少樣板代碼</td>
                                        <td class="lang-en hidden">Need Redux but want less boilerplate</td>
                                        <td class="lang-zh">良好</td>
                                        <td class="lang-en hidden">Good</td>
                                    </tr>
                                    <tr>
                                        <td>Zustand</td>
                                        <td class="lang-zh">中</td>
                                        <td class="lang-en hidden">Medium</td>
                                        <td class="lang-zh">容易</td>
                                        <td class="lang-en hidden">Easy</td>
                                        <td class="lang-zh">中型應用，希望簡化的 Redux</td>
                                        <td class="lang-en hidden">Medium apps, simplified Redux</td>
                                        <td class="lang-zh">良好</td>
                                        <td class="lang-en hidden">Good</td>
                                    </tr>
                                    <tr>
                                        <td>Recoil</td>
                                        <td class="lang-zh">中高</td>
                                        <td class="lang-en hidden">Medium-High</td>
                                        <td class="lang-zh">中等</td>
                                        <td class="lang-en hidden">Moderate</td>
                                        <td class="lang-zh">需要精細控制的複雜應用</td>
                                        <td class="lang-en hidden">Complex apps needing fine-grained control</td>
                                        <td class="lang-zh">非常好</td>
                                        <td class="lang-en hidden">Very Good</td>
                                    </tr>
                                    <tr>
                                        <td>Jotai</td>
                                        <td class="lang-zh">中</td>
                                        <td class="lang-en hidden">Medium</td>
                                        <td class="lang-zh">較易</td>
                                        <td class="lang-en hidden">Fairly Easy</td>
                                        <td class="lang-zh">需要原子化狀態的中型應用</td>
                                        <td class="lang-en hidden">Medium apps needing atomic state</td>
                                        <td class="lang-zh">非常好</td>
                                        <td class="lang-en hidden">Very Good</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>
                    
                    <!-- 選擇指南 -->
                    <section id="selection-guide">
                        <h2 class="lang-zh">選擇指南</h2>
                        <h2 class="lang-en hidden">Selection Guide</h2>
                        
                        <p class="lang-zh">
                            選擇正確的狀態管理方案取決於你的項目需求、團隊經驗和個人偏好。以下是一些指導原則：
                        </p>
                        <p class="lang-en hidden">
                            Choosing the right state management solution depends on your project requirements, team experience, and personal preferences. Here are some guidelines:
                        </p>
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
                            <div class="card bg-base-100 shadow-sm">
                                <div class="card-body">
                                    <h3 class="card-title lang-zh">使用內置 Hook (useState/useReducer)</h3>
                                    <h3 class="card-title lang-en hidden">Use Built-in Hooks (useState/useReducer)</h3>
                                    <ul>
                                        <li class="lang-zh">當應用較小或是原型階段</li>
                                        <li class="lang-en hidden">When the application is small or in prototype stage</li>
                                        <li class="lang-zh">狀態邏輯相對簡單</li>
                                        <li class="lang-en hidden">State logic is relatively simple</li>
                                        <li class="lang-zh">組件之間的狀態共享有限</li>
                                        <li class="lang-en hidden">Limited state sharing between components</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="card bg-base-100 shadow-sm">
                                <div class="card-body">
                                    <h3 class="card-title lang-zh">使用 Context API</h3>
                                    <h3 class="card-title lang-en hidden">Use Context API</h3>
                                    <ul>
                                        <li class="lang-zh">當需要在組件樹中共享狀態</li>
                                        <li class="lang-en hidden">When state needs to be shared across the component tree</li>
                                        <li class="lang-zh">應用規模中等</li>
                                        <li class="lang-en hidden">Medium-sized applications</li>
                                        <li class="lang-zh">不想引入額外的依賴</li>
                                        <li class="lang-en hidden">Don't want to introduce additional dependencies</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="card bg-base-100 shadow-sm">
                                <div class="card-body">
                                    <h3 class="card-title lang-zh">使用 Redux/Redux Toolkit</h3>
                                    <h3 class="card-title lang-en hidden">Use Redux/Redux Toolkit</h3>
                                    <ul>
                                        <li class="lang-zh">大型應用與複雜狀態</li>
                                        <li class="lang-en hidden">Large applications with complex state</li>
                                        <li class="lang-zh">需要時間旅行調試和強大的開發工具</li>
                                        <li class="lang-en hidden">Need time-travel debugging and powerful dev tools</li>
                                        <li class="lang-zh">團隊已熟悉 Redux 生態系統</li>
                                        <li class="lang-en hidden">Team is already familiar with Redux ecosystem</li>
                                        <li class="lang-zh">需要中間件處理複雜的副作用</li>
                                        <li class="lang-en hidden">Need middleware for complex side effects</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="card bg-base-100 shadow-sm">
                                <div class="card-body">
                                    <h3 class="card-title lang-zh">使用 Zustand</h3>
                                    <h3 class="card-title lang-en hidden">Use Zustand</h3>
                                    <ul>
                                        <li class="lang-zh">需要 Redux 風格的狀態管理但更輕量</li>
                                        <li class="lang-en hidden">Need Redux-style state management but lighter</li>
                                        <li class="lang-zh">喜歡基於 Hook 的簡單 API</li>
                                        <li class="lang-en hidden">Prefer simple Hook-based API</li>
                                        <li class="lang-zh">不想處理大量的樣板代碼</li>
                                        <li class="lang-en hidden">Don't want to deal with lots of boilerplate</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="card bg-base-100 shadow-sm">
                                <div class="card-body">
                                    <h3 class="card-title lang-zh">使用 Recoil/Jotai</h3>
                                    <h3 class="card-title lang-en hidden">Use Recoil/Jotai</h3>
                                    <ul>
                                        <li class="lang-zh">需要原子化和精細的狀態控制</li>
                                        <li class="lang-en hidden">Need atomic and fine-grained state control</li>
                                        <li class="lang-zh">關注狀態派生和異步處理</li>
                                        <li class="lang-en hidden">Focus on state derivation and async handling</li>
                                        <li class="lang-zh">使用 React 並發模式/Suspense</li>
                                        <li class="lang-en hidden">Using React Concurrent Mode/Suspense</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </section>
                    
                    <!-- 最佳實踐 -->
                    <section id="best-practices">
                        <h2 class="lang-zh">最佳實踐</h2>
                        <h2 class="lang-en hidden">Best Practices</h2>
                        
                        <p class="lang-zh">
                            無論你選擇哪種狀態管理方案，以下最佳實踐可以幫助你更有效地管理狀態：
                        </p>
                        <p class="lang-en hidden">
                            Regardless of which state management solution you choose, the following best practices can help you manage state more effectively:
                        </p>
                        
                        <ol>
                            <li class="lang-zh"><strong>保持狀態最小化</strong> - 只存儲必要的數據，避免冗餘或可計算的狀態</li>
                            <li class="lang-en hidden"><strong>Keep State Minimal</strong> - Only store what's necessary, avoid redundant or computable state</li>
                            
                            <li class="lang-zh"><strong>合理分類狀態</strong> - 區分局部/共享/全局狀態，使用適當的工具管理每種類型</li>
                            <li class="lang-en hidden"><strong>Categorize State Wisely</strong> - Distinguish between local/shared/global state, use appropriate tools for each type</li>
                            
                            <li class="lang-zh"><strong>避免深層嵌套</strong> - 保持狀態結構扁平，便於更新和維護</li>
                            <li class="lang-en hidden"><strong>Avoid Deep Nesting</strong> - Keep state structures flat for easier updates and maintenance</li>
                            
                            <li class="lang-zh"><strong>遵循不可變更新模式</strong> - 始終創建新的狀態對象而不是修改現有的</li>
                            <li class="lang-en hidden"><strong>Follow Immutable Update Patterns</strong> - Always create new state objects rather than modifying existing ones</li>
                            
                            <li class="lang-zh"><strong>規範命名</strong> - 使用一致、明確的命名約定</li>
                            <li class="lang-en hidden"><strong>Standardize Naming</strong> - Use consistent, clear naming conventions</li>
                            
                            <li class="lang-zh"><strong>分離關注點</strong> - 將狀態邏輯與 UI 邏輯分離</li>
                            <li class="lang-en hidden"><strong>Separate Concerns</strong> - Separate state logic from UI logic</li>
                            
                            <li class="lang-zh"><strong>編寫測試</strong> - 為狀態管理邏輯（特別是 reducers 和選擇器）編寫單元測試</li>
                            <li class="lang-en hidden"><strong>Write Tests</strong> - Write unit tests for state management logic (especially reducers and selectors)</li>
                            
                            <li class="lang-zh"><strong>性能優化</strong> - 使用記憶化(memoization)、選擇性訂閱和其他優化技術避免不必要的重新渲染</li>
                            <li class="lang-en hidden"><strong>Optimize Performance</strong> - Use memoization, selective subscriptions, and other techniques to avoid unnecessary re-renders</li>
                        </ol>
                    </section>
                    
                    <!-- 總結 -->
                    <section id="conclusion">
                        <h2 class="lang-zh">總結</h2>
                        <h2 class="lang-en hidden">Conclusion</h2>
                        
                        <p class="lang-zh">
                            React 的狀態管理有多種解決方案，從內置 Hook 到第三方庫。選擇正確的方案取決於你的項目規模、複雜度和團隊偏好。
                        </p>
                        <p class="lang-en hidden">
                            React state management has multiple solutions, from built-in Hooks to third-party libraries. Choosing the right solution depends on your project size, complexity, and team preferences.
                        </p>
                        
                        <p class="lang-zh">
                            對於小型應用，React 的 useState 和 useReducer 通常已經足夠。中型應用可以利用 Context API 和自定義 Hook 組合。大型和複雜的應用可能需要專門的狀態管理庫如 Redux、Zustand 或 Recoil。
                        </p>
                        <p class="lang-en hidden">
                            For small applications, React's useState and useReducer are usually sufficient. Medium-sized applications can leverage the Context API and custom Hooks. Large and complex applications might require dedicated state management libraries like Redux, Zustand, or Recoil.
                        </p>
                        
                        <p class="lang-zh">
                            無論你選擇哪種解決方案，良好的狀態設計和最佳實踐對於構建可維護和高效的 React 應用都至關重要。始終考慮你的應用需求和團隊能力，選擇最適合你的特定情況的工具。
                        </p>
                        <p class="lang-en hidden">
                            Regardless of which solution you choose, good state design and best practices are crucial for building maintainable and efficient React applications. Always consider your application needs and team capabilities, and choose the tools that best fit your specific situation.
                        </p>
                    </section>
                </article>

                <!-- 前後文章導航 -->
                <div class="flex justify-between mt-12">
                    <a href="hooks-best-practices.html" class="btn btn-outline">
                        <span class="lang-zh">← Hooks 最佳實踐</span>
                        <span class="lang-en hidden">← Hooks Best Practices</span>
                    </a>
                    <a href="context-api.html" class="btn btn-outline">
                        <span class="lang-zh">Context API 使用指南 →</span>
                        <span class="lang-en hidden">Context API Guide →</span>
                    </a>
                </div>
            </div>
        </div>
    </main>

    <!-- 頁腳 -->
    <footer class="footer footer-center p-4 bg-base-200 text-base-content">
        <div>
            <p class="lang-zh">© 2025 - 使用 Tailwind CSS 與 DaisyUI 構建</p>
            <p class="lang-en hidden">© 2025 - Built with Tailwind CSS and DaisyUI</p>
        </div>
    </footer>

    <!-- JavaScript 切換功能 -->
    <script>
        // 主題切換
        const themeToggle = document.getElementById('themeToggle');
        const htmlElement = document.documentElement;
        const themeLightIcon = document.querySelector('.theme-light');
        const themeDarkIcon = document.querySelector('.theme-dark');

        themeToggle.addEventListener('click', () => {
            const currentTheme = htmlElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            htmlElement.setAttribute('data-theme', newTheme);
            
            if (newTheme === 'dark') {
                themeLightIcon.classList.add('hidden');
                themeDarkIcon.classList.remove('hidden');
            } else {
                themeLightIcon.classList.remove('hidden');
                themeDarkIcon.classList.add('hidden');
            }
            
            // 儲存主題偏好到本地存儲
            localStorage.setItem('theme', newTheme);
        });

        // 語言切換
        const langToggle = document.getElementById('langToggle');
        const langDisplay = document.getElementById('langDisplay');
        const zhElements = document.querySelectorAll('.lang-zh');
        const enElements = document.querySelectorAll('.lang-en');

        // 定義當前語言（默認中文）
        let currentLang = localStorage.getItem('language') || 'zh';
        
        // 設置初始語言顯示
        updateLanguageDisplay();
        
        langToggle.addEventListener('click', () => {
            // 切換語言
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            
            // 更新元素顯示
            updateLanguageState();
            
            // 儲存語言偏好到本地存儲
            localStorage.setItem('language', currentLang);
        });
        
        // 更新語言狀態的函數
        function updateLanguageState() {
            if (currentLang === 'zh') {
                zhElements.forEach(el => el.classList.remove('hidden'));
                enElements.forEach(el => el.classList.add('hidden'));
                langDisplay.textContent = '中/EN';
            } else {
                zhElements.forEach(el => el.classList.add('hidden'));
                enElements.forEach(el => el.classList.remove('hidden'));
                langDisplay.textContent = 'EN/中';
            }
        }
        
        // 更新語言顯示
        function updateLanguageDisplay() {
            langDisplay.textContent = currentLang === 'zh' ? '中/EN' : 'EN/中';
            updateLanguageState();
        }

        // 頁面加載時讀取使用者偏好
        document.addEventListener('DOMContentLoaded', () => {
            // 載入主題偏好
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                htmlElement.setAttribute('data-theme', savedTheme);
                if (savedTheme === 'dark') {
                    themeLightIcon.classList.add('hidden');
                    themeDarkIcon.classList.remove('hidden');
                }
            }
            
            // 載入語言偏好
            const savedLanguage = localStorage.getItem('language');
            if (savedLanguage) {
                currentLang = savedLanguage;
                updateLanguageState();
            }
        });
    </script>